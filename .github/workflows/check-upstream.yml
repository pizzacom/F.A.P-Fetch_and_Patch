name: Patch APKs

on:
  schedule:
    - cron: "0 */6 * * *"  # Every 6 hours
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if already processed'
        required: false
        default: false
        type: boolean

permissions:
  contents: write

jobs:
  patch:
    runs-on: ubuntu-latest
    env:
      PATCHES_REPO: ${{ vars.PATCHES_REPO }}
      MORPHE_CLI_REPO: ${{ vars.MORPHE_CLI_REPO }}
      MORPHE_CLI_ASSET: ${{ vars.MORPHE_CLI_ASSET }}
      MORPHE_PATCHES_ASSET: ${{ vars.MORPHE_PATCHES_ASSET }}
      MORPHE_PATCH_EXTRA_ARGS: ${{ vars.MORPHE_PATCH_EXTRA_ARGS }}
      APKMIRROR_ORG: ${{ vars.APKMIRROR_ORG }}
      APKMIRROR_ARCH: ${{ vars.APKMIRROR_ARCH }}
      APKMIRROR_DPI: ${{ vars.APKMIRROR_DPI }}
      YOUTUBE_APKMIRROR_APP: ${{ vars.YOUTUBE_APKMIRROR_APP }}
      YOUTUBE_MUSIC_APKMIRROR_APP: ${{ vars.YOUTUBE_MUSIC_APKMIRROR_APP }}
      YOUTUBE_VERSION: ${{ vars.YOUTUBE_VERSION }}
      YOUTUBE_MUSIC_VERSION: ${{ vars.YOUTUBE_MUSIC_VERSION }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      DISCORD_ROLE_ID: ${{ vars.DISCORD_ROLE_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java 11
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "11"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Restore last release state
        uses: actions/cache@v4
        with:
          path: .state
          key: state-${{ github.run_id }}
          restore-keys: |
            state-

      - name: Validate required inputs
        run: |
          set -euo pipefail
          if [ -z "${DISCORD_WEBHOOK_URL:-}" ]; then
            echo "Missing DISCORD_WEBHOOK_URL secret." >&2
            exit 1
          fi

      - name: Check for new patches release
        id: patches
        run: |
          set -euo pipefail
          mkdir -p .state

          patches_repo="${PATCHES_REPO:-MorpheApp/morphe-patches}"
          patches_asset="${MORPHE_PATCHES_ASSET:-patches.mpp}"

          releases_json=$(curl -fsSL "https://api.github.com/repos/${patches_repo}/releases?per_page=10")
          latest_release=$(echo "$releases_json" | jq -c '[.[] | select(.draft==false)] | .[0]')
          latest_tag=$(echo "$latest_release" | jq -r '.tag_name')
          is_prerelease=$(echo "$latest_release" | jq -r '.prerelease')
          if [ -z "$latest_tag" ] || [ "$latest_tag" = "null" ]; then
            echo "No releases found for ${patches_repo}." >&2
            exit 1
          fi

          asset_url=$(echo "$releases_json" | jq -r --arg tag "$latest_tag" --arg name "$patches_asset" '
            ([.[] | select(.tag_name==$tag) | .assets[] | select(.name==$name) | .browser_download_url][0]) // empty
          ')
          if [ -z "$asset_url" ] || [ "$asset_url" = "null" ]; then
            asset_url=$(echo "$releases_json" | jq -r --arg tag "$latest_tag" '
              [.[] | select(.tag_name==$tag) | .assets[] | select(.name | endswith(".mpp")) | .browser_download_url][0]
            ')
          fi
          if [ -z "$asset_url" ] || [ "$asset_url" = "null" ]; then
            echo "No .mpp asset found in ${patches_repo} release ${latest_tag}." >&2
            exit 1
          fi

          last_tag=""
          if [ -f .state/last_release.txt ]; then
            last_tag=$(cat .state/last_release.txt)
          fi

          echo "latest_tag=${latest_tag}" >> "$GITHUB_OUTPUT"
          echo "asset_url=${asset_url}" >> "$GITHUB_OUTPUT"
          echo "last_tag=${last_tag}" >> "$GITHUB_OUTPUT"
          echo "is_prerelease=${is_prerelease}" >> "$GITHUB_OUTPUT"

      - name: Skip if already processed
        if: ${{ steps.patches.outputs.latest_tag == steps.patches.outputs.last_tag && inputs.force_rebuild != true }}
        run: echo "Already processed release ${{ steps.patches.outputs.latest_tag }}"

      - name: Download Morphe CLI
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        run: |
          set -euo pipefail
          cli_repo="${MORPHE_CLI_REPO:-MorpheApp/morphe-cli}"
          cli_asset="${MORPHE_CLI_ASSET:-morphe-cli.jar}"

          cli_json=$(curl -fsSL "https://api.github.com/repos/${cli_repo}/releases?per_page=10")
          cli_tag=$(echo "$cli_json" | jq -r '[.[] | select(.draft==false)] | .[0].tag_name')
          if [ -z "$cli_tag" ] || [ "$cli_tag" = "null" ]; then
            echo "No releases found for ${cli_repo}." >&2
            exit 1
          fi

          cli_url=$(echo "$cli_json" | jq -r --arg tag "$cli_tag" --arg name "$cli_asset" '
            [.[] | select(.tag_name==$tag) | .assets[] | select(.name==$name) | .browser_download_url][0]
          ')
          if [ -z "$cli_url" ] || [ "$cli_url" = "null" ]; then
            cli_url=$(echo "$cli_json" | jq -r --arg tag "$cli_tag" '
              [.[] | select(.tag_name==$tag) | .assets[] | select(.name | endswith(".jar")) | .browser_download_url][0]
            ')
          fi
          if [ -z "$cli_url" ] || [ "$cli_url" = "null" ]; then
            echo "No .jar asset found in ${cli_repo} release ${cli_tag}." >&2
            exit 1
          fi

          curl -fsSL "$cli_url" -o morphe-cli.jar

      - name: Download patches bundle
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        run: |
          set -euo pipefail
          curl -fsSL "${{ steps.patches.outputs.asset_url }}" -o patches.mpp

      - name: Detect compatible versions
        id: versions
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        run: |
          set -euo pipefail

          yt_pkg="com.google.android.youtube"
          ytm_pkg="com.google.android.apps.youtube.music"

          if [ -n "${YOUTUBE_VERSION:-}" ] && [ -n "${YOUTUBE_MUSIC_VERSION:-}" ]; then
            echo "youtube_version=${YOUTUBE_VERSION}" >> "$GITHUB_OUTPUT"
            echo "youtube_music_version=${YOUTUBE_MUSIC_VERSION}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          output=$(java -jar morphe-cli.jar list-versions -f "$yt_pkg" -f "$ytm_pkg" patches.mpp)
          echo "Morphe CLI output:"
          echo "$output"

          # Parse versions - get the LAST (newest/recommended) version for each package
          # The list-versions output shows versions with the newest/recommended at the bottom
          yt_version=$(echo "$output" | awk -v pkg="$yt_pkg" '
            $0 ~ "Package name: "pkg {inblock=1; next}
            inblock && /^[[:space:]]/ {gsub(/^[[:space:]]+/, ""); sub(/[[:space:]].*/, ""); if ($0 ~ /^[0-9]/) {ver=$0}}
            inblock && /^Package name:/ {exit}
            END {print ver}
          ')
          ytm_version=$(echo "$output" | awk -v pkg="$ytm_pkg" '
            $0 ~ "Package name: "pkg {inblock=1; next}
            inblock && /^[[:space:]]/ {gsub(/^[[:space:]]+/, ""); sub(/[[:space:]].*/, ""); if ($0 ~ /^[0-9]/) {ver=$0}}
            inblock && /^Package name:/ {exit}
            END {print ver}
          ')

          # Fallback: try grep-based approach getting the last version match
          if [ -z "$yt_version" ]; then
            yt_version=$(echo "$output" | grep -A100 "$yt_pkg" | grep -oE '^[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' | tail -1 | tr -d '[:space:]')
          fi
          if [ -z "$ytm_version" ]; then
            ytm_version=$(echo "$output" | grep -A100 "$ytm_pkg" | grep -oE '^[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' | tail -1 | tr -d '[:space:]')
          fi

          if [ -z "$yt_version" ] || [ -z "$ytm_version" ]; then
            echo "Failed to detect compatible versions from morphe-cli output." >&2
            echo "Detected YouTube version: '$yt_version'" >&2
            echo "Detected YouTube Music version: '$ytm_version'" >&2
            exit 1
          fi

          echo "Detected YouTube version: $yt_version"
          echo "Detected YouTube Music version: $ytm_version"
          echo "youtube_version=$yt_version" >> "$GITHUB_OUTPUT"
          echo "youtube_music_version=$ytm_version" >> "$GITHUB_OUTPUT"

      - name: Download target APKs from APKMirror
        id: download
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        run: |
          set -euo pipefail
          mkdir -p input

          apkmirror_org="${APKMIRROR_ORG:-google-inc}"
          youtube_app="${YOUTUBE_APKMIRROR_APP:-youtube}"
          youtube_music_app="${YOUTUBE_MUSIC_APKMIRROR_APP:-youtube-music}"
          arch="${APKMIRROR_ARCH:-arm64-v8a}"
          dpi="${APKMIRROR_DPI:-nodpi}"

          npm install -g apkmirror-downloader

          cat > apps.json <<EOF
          {
            "options": {
              "arch": "${arch}",
              "dpi": "${dpi}",
              "outDir": "input"
            },
            "apps": [
              {
                "org": "${apkmirror_org}",
                "repo": "${youtube_app}",
                "version": "${{ steps.versions.outputs.youtube_version }}",
                "outFile": "rvx-core.apk"
              },
              {
                "org": "${apkmirror_org}",
                "repo": "${youtube_music_app}",
                "version": "${{ steps.versions.outputs.youtube_music_version }}",
                "outFile": "rvx-media.apk"
              }
            ]
          }
          EOF

          apkmd_bin=$(command -v apkmd)
          download_success=false
          
          # 5 minute timeout per attempt (300 seconds)
          TIMEOUT_SECONDS=300
          
          for attempt in 1 2 3; do
            echo "Download attempt $attempt of 3 (timeout: ${TIMEOUT_SECONDS}s)..."
            if timeout "${TIMEOUT_SECONDS}s" node "$apkmd_bin" apps.json; then
              download_success=true
              break
            fi
            exit_code=$?
            if [ $exit_code -eq 124 ]; then
              echo "Download timed out after ${TIMEOUT_SECONDS} seconds (attempt $attempt)." >&2
            else
              echo "APKMirror download failed with exit code $exit_code (attempt $attempt)." >&2
            fi
            if [ $attempt -lt 3 ]; then
              echo "Retrying in 10 seconds..."
              sleep 10
            fi
          done

          if [ "$download_success" != "true" ]; then
            echo "download_failed=true" >> "$GITHUB_OUTPUT"
            echo "All download attempts failed." >&2
            exit 1
          fi

          test -f "$PWD/input/rvx-core.apk"
          test -f "$PWD/input/rvx-media.apk"
          echo "download_failed=false" >> "$GITHUB_OUTPUT"

      - name: Notify Discord on download failure
        if: ${{ failure() && steps.download.outputs.download_failed == 'true' }}
        run: |
          set -euo pipefail
          
          # Role mention (set DISCORD_ROLE_ID in repository variables)
          role_ping=""
          if [ -n "${DISCORD_ROLE_ID:-}" ]; then
            role_ping="<@&${DISCORD_ROLE_ID}>"
          fi
          
          payload=$(jq -n \
            --arg yt_ver "${{ steps.versions.outputs.youtube_version }}" \
            --arg ytm_ver "${{ steps.versions.outputs.youtube_music_version }}" \
            --arg ping "$role_ping" \
            '{
              "content": (if $ping != "" then $ping else null end),
              "username": "Morphe Patcher",
              "embeds": [
                {
                  "title": "âš ï¸ APK Download Failed",
                  "description": ("Download from APKMirror timed out or failed after 3 attempts.\n\nYouTube version: " + $yt_ver + "\nYouTube Music version: " + $ytm_ver),
                  "color": 15158332
                }
              ]
            }')
          curl -fsSL -H "Content-Type: application/json" -d "$payload" "$DISCORD_WEBHOOK_URL"

      - name: Patch APKs
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        run: |
          set -euo pipefail
          mkdir -p dist

          extra_args=${MORPHE_PATCH_EXTRA_ARGS:-}

          java -jar morphe-cli.jar patch -p patches.mpp -o dist/rvx-core-patched.apk $extra_args input/rvx-core.apk
          java -jar morphe-cli.jar patch -p patches.mpp -o dist/rvx-media-patched.apk $extra_args input/rvx-media.apk

          test -f "$PWD/dist/rvx-core-patched.apk"
          test -f "$PWD/dist/rvx-media-patched.apk"

      - name: Create or update release
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="patched-${{ steps.patches.outputs.latest_tag }}"
          title="Patched APKs (${{ steps.patches.outputs.latest_tag }})"
          notes="Automated build for patches release ${{ steps.patches.outputs.latest_tag }}."
          is_prerelease="${{ steps.patches.outputs.is_prerelease }}"

          prerelease_flag=""
          if [ "$is_prerelease" = "true" ]; then
            prerelease_flag="--prerelease"
            title="Patched APKs (${{ steps.patches.outputs.latest_tag }}) [Pre-release]"
          fi

          if gh release view "$tag" >/dev/null 2>&1; then
            gh release upload "$tag" "dist/rvx-core-patched.apk" "dist/rvx-media-patched.apk" --clobber
          else
            gh release create "$tag" "dist/rvx-core-patched.apk" "dist/rvx-media-patched.apk" --title "$title" --notes "$notes" $prerelease_flag
          fi

      - name: Notify Discord
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="${GITHUB_REPOSITORY}"
          tag="patched-${{ steps.patches.outputs.latest_tag }}"
          is_prerelease="${{ steps.patches.outputs.is_prerelease }}"

          release_json=$(gh api "repos/${repo}/releases/tags/${tag}")
          yt_url=$(echo "$release_json" | jq -r '.assets[] | select(.name=="rvx-core-patched.apk") | .browser_download_url')
          ytm_url=$(echo "$release_json" | jq -r '.assets[] | select(.name=="rvx-media-patched.apk") | .browser_download_url')

          # Set color and title based on release type
          if [ "$is_prerelease" = "true" ]; then
            color=16744192  # Orange for pre-release
            title="ðŸ§ª New Pre-release APKs Available"
          else
            color=5763719   # Green for stable
            title="âœ… New Patched APKs Available"
          fi

          # Role mention (set DISCORD_ROLE_ID in repository variables)
          role_ping=""
          if [ -n "${DISCORD_ROLE_ID:-}" ]; then
            role_ping="<@&${DISCORD_ROLE_ID}>"
          fi

          payload=$(jq -n \
            --arg title "$title" \
            --arg yt "$yt_url" \
            --arg ytm "$ytm_url" \
            --arg yt_ver "${{ steps.versions.outputs.youtube_version }}" \
            --arg ytm_ver "${{ steps.versions.outputs.youtube_music_version }}" \
            --arg ping "$role_ping" \
            --argjson color "$color" \
            '{
              "content": (if $ping != "" then $ping else null end),
              "username": "Morphe Patcher",
              "embeds": [
                {
                  "title": $title,
                  "color": $color,
                  "fields": [
                    {
                      "name": "ðŸ“º YouTube",
                      "value": ("Version: `" + $yt_ver + "`\n[â¬‡ï¸ Download](" + $yt + ")"),
                      "inline": true
                    },
                    {
                      "name": "ðŸŽµ YouTube Music",
                      "value": ("Version: `" + $ytm_ver + "`\n[â¬‡ï¸ Download](" + $ytm + ")"),
                      "inline": true
                    }
                  ],
                  "footer": {
                    "text": "Patches: ${{ steps.patches.outputs.latest_tag }}"
                  },
                  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
                }
              ]
            }')

          curl -fsSL -H "Content-Type: application/json" -d "$payload" "$DISCORD_WEBHOOK_URL"

      - name: Save release state
        if: ${{ steps.patches.outputs.latest_tag != steps.patches.outputs.last_tag || inputs.force_rebuild == true }}
        run: |
          set -euo pipefail
          echo "${{ steps.patches.outputs.latest_tag }}" > .state/last_release.txt
